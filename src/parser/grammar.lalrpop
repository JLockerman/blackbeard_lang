use std::str::FromStr;
use crate::parser::ast::{Statement, Declaration, Type, Expression};

grammar;

pub Program: Vec<Statement> = (<Statement>)*;

pub Statement: Statement = {
    <var: (<Identifier> "=")?> <expr: Expression> ";" =>
        crate::parser::ast::Statement::Assignment{var, expr},
    <Declaration> => Statement::Declaration(<>),
};

pub Declaration: Declaration = {
    "function" <name: Identifier> "(" <args: Comma<NameAndType>> ")"
        <returns: (":" <Type>)?> "{" <body: Program> "}" =>
            Declaration::Function{name, args, returns, body},
    "object" <name: Identifier> "{" <fields: Comma<NameAndType>> "}" =>
        Declaration::Object{name, fields},
};

NameAndType: (String, Type) = {
    <Identifier> ":" <Type> => (<>),
};

Type: Type = {
    "{}->" <base: Type> => Type::Pointer(base.into()),
    "[" <SliceType> "]",
    <base: Identifier> => Type::Named(base.into()),
};

SliceType: Type = {
    "..." <Type> => Type::Slice(<>.into()),
    "..?" <Type> => Type::UninitSlice(<>.into()),
    <length: UnsignedInteger> <ty: Type> => Type::Array(length, ty.into()),
}

pub Expression: Expression = {
    <function: Identifier> "(" <args: Comma<Expression>> ")" =>
        Expression::Call{function, args},
    <Identifier> => Expression::Variable(<>),
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Identifier: String = <identifier> => String::from_str(<>).unwrap();

UnsignedInteger: u64 = <integer> => u64::from_str(<>)
    .expect("invalid integer");

match {
    "{}->" => "{}->",
    ":" => ":",
} else {
    r"//[^\n\r]*[\n\r]*" => {}, // Skip `// comments`
    "function",
    "object",
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    "=",
    ",",
    ";",
    "...",
    "..?"
} else {
    r"\s*" => {},
    r"\d+" => integer,
    r"[[:alpha:]]\w*" => identifier,
}
